Here's the canonical Phoenix environment setup that most developers use with minimal customization:

## Standard Phoenix Config Structure

Phoenix generates this by default and most apps stick with it:

```elixir
# config/config.exs
import Config

# Shared config across all environments
config :my_app, MyAppWeb.Endpoint,
  url: [host: "localhost"],
  render_errors: [view: MyAppWeb.ErrorView, accepts: ~w(html json)]

# Import environment specific config
import_config "#{config_env()}.exs"
```

```elixir
# config/runtime.exs (the key file for production)
import Config

if config_env() == :prod do
  database_url = System.get_env("DATABASE_URL") ||
    raise "environment variable DATABASE_URL is missing"

  config :my_app, MyApp.Repo,
    url: database_url,
    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10")

  secret_key_base = System.get_env("SECRET_KEY_BASE") ||
    raise "environment variable SECRET_KEY_BASE is missing"

  config :my_app, MyAppWeb.Endpoint,
    http: [port: String.to_integer(System.get_env("PORT") || "4000")],
    secret_key_base: secret_key_base
end
```

## Canonical Environment Checking

**Most Phoenix apps use this pattern:**

```elixir
# Check environment at runtime
Application.get_env(:my_app, :environment, :dev)

# Or check specific feature flags
Application.get_env(:my_app, :enable_debug_logging, false)
```

**In your app code:**
```elixir
# config/prod.exs
config :my_app, :enable_debug_logging, false

# config/dev.exs  
config :my_app, :enable_debug_logging, true

# In your application
if Application.get_env(:my_app, :enable_debug_logging) do
  Logger.debug("Debug info here")
end
```

## Standard Fly.io Setup

Most Phoenix apps on Fly use the default generated files:

```toml
# fly.toml (generated by `fly launch`)
app = "my-app"
primary_region = "sjc"

[build]

[http_service]
  internal_port = 4000
  force_https = true

[[vm]]
  cpu_kind = "shared"
  cpus = 1
  memory_mb = 256

[env]
  PHX_HOST = "my-app.fly.dev"
```

```dockerfile
# Dockerfile (generated by Phoenix 1.7+)
FROM hexpm/elixir:1.15.4-erlang-26.0.2-debian-bullseye-20230612-slim as builder

# ... standard Phoenix Dockerfile
# Runs mix release which uses config/runtime.exs
```

## The Canonical Pattern

**90% of Phoenix apps follow this exact pattern:**

1. **Build-time config**: Use `config/dev.exs`, `config/prod.exs` for static config
2. **Runtime config**: Use `config/runtime.exs` with `config_env() == :prod` for environment variables
3. **App code**: Use `Application.get_env/3` for runtime checks
4. **Deploy**: Standard `mix release` (which Fly.io uses automatically)

**Example of the most common pattern:**

```elixir
# config/prod.exs
config :my_app, :external_api_enabled, true

# config/dev.exs
config :my_app, :external_api_enabled, false

# In your code
if Application.get_env(:my_app, :external_api_enabled, false) do
  ExternalAPI.call()
else
  {:ok, :mocked_response}
end
```

This works reliably because:
- Config is baked into the release at build time
- `Application.get_env/3` works in all environments
- No dependency on Mix in production
- Standard pattern that all Phoenix tooling expects

The key insight: **don't check `Mix.env` directly**. Use the config system that Phoenix provides, which works identically across all environments.